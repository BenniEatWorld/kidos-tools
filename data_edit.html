<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Data Editor - Kidos Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="css/main.css" />
  <link rel="stylesheet" href="css/tools-forms.css" />
  <style>
    /* Data Editor spezifische Styles */
    :root {
      --editor-primary: #2c3e50;
      --editor-secondary: #34495e;
      --editor-accent: #3498db;
      --editor-success: #27ae60;
      --editor-warning: #f39c12;
      --editor-danger: #e74c3c;
    }

    .data-editor-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .editor-header {
      background: var(--editor-primary);
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }

    .editor-controls {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 20px;
      margin-bottom: 20px;
      height: calc(100vh - 200px);
    }

    .file-selector {
      background: var(--editor-secondary);
      padding: 15px;
      border-radius: 8px;
      color: white;
      overflow-y: auto;
    }

    .json-editor {
      background: var(--editor-secondary);
      padding: 15px;
      border-radius: 8px;
      color: white;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .file-list {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      max-height: 300px;
      overflow-y: auto;
    }

    .file-item {
      background: var(--editor-primary);
      margin: 3px 0;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      border-left: 4px solid transparent;
      font-size: 13px;
    }

    .file-item:hover {
      background: var(--editor-accent);
      border-left-color: white;
    }

    .file-item.active {
      background: var(--editor-accent);
      border-left-color: var(--editor-success);
    }

    .json-content {
      width: 100%;
      flex: 1;
      min-height: 300px;
      background: #ffffff;
      color: #333333;
      border: 1px solid var(--editor-accent);
      border-radius: 5px;
      padding: 20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      line-height: 1.6;
      overflow-y: auto;
    }

    /* Block-basierter Editor */
    .block-editor {
      background: #ffffff;
      min-height: 400px;
      padding: 20px;
    }

    .content-block {
      margin: 15px 0;
      position: relative;
      border-radius: 8px;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .content-block:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .content-block.editing {
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
      cursor: text;
    }

    .block-content {
      padding: 12px 16px;
      border-radius: 6px;
      border-left: 4px solid;
      background: white;
      position: relative;
      min-height: 40px;
      display: flex;
      align-items: center;
    }

    .block-title {
      border-left-color: #3498db;
      background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%);
      font-size: 24px;
      font-weight: bold;
      text-align: center;
    }

    .block-category {
      border-left-color: #e74c3c;
      background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%);
      font-size: 20px;
      font-weight: bold;
    }

    .block-subcategory {
      border-left-color: #f39c12;
      background: linear-gradient(135deg, #fffbf0 0%, #fff3d6 100%);
      font-size: 18px;
      font-weight: 600;
      margin-left: 30px;
    }

    .block-statement {
      border-left-color: #27ae60;
      background: linear-gradient(135deg, #f0fff4 0%, #e6ffe6 100%);
      font-size: 16px;
      margin-left: 60px;
    }

    .block-text {
      flex: 1;
      border: none;
      background: transparent;
      font-size: inherit;
      font-weight: inherit;
      color: inherit;
      outline: none;
      width: 100%;
      padding: 0;
      resize: none;
      font-family: inherit;
    }

    .block-text:not(.editing) {
      pointer-events: none;
    }

    .block-controls {
      position: absolute;
      top: 8px;
      right: 8px;
      display: none;
      gap: 5px;
    }

    .content-block:hover .block-controls {
      display: flex;
    }

    .block-btn {
      background: rgba(0,0,0,0.6);
      color: white;
      border: none;
      border-radius: 3px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .block-btn:hover {
      background: rgba(0,0,0,0.8);
    }

    .block-btn.delete {
      background: #e74c3c;
    }

    .block-btn.delete:hover {
      background: #c0392b;
    }

    /* Plus-Button zwischen Blöcken */
    .block-divider {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 10px 0;
      position: relative;
    }

    .block-divider::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: #e0e0e0;
      z-index: 1;
    }

    .plus-button {
      background: #3498db;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 2;
      position: relative;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }

    .plus-button:hover {
      background: #2980b9;
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
    }

    /* Dropdown für Blocktyp-Auswahl */
    .block-type-dropdown {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      display: none;
      min-width: 180px;
    }

    .block-type-option {
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.2s ease;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .block-type-option:last-child {
      border-bottom: none;
    }

    .block-type-option:hover {
      background: #f8f9fa;
    }

    .block-type-option .icon {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
    }

    .block-type-option.title .icon {
      background: #3498db;
    }

    .block-type-option.category .icon {
      background: #e74c3c;
    }

    .block-type-option.subcategory .icon {
      background: #f39c12;
    }

    .block-type-option.statement .icon {
      background: #27ae60;
    }

    /* Editor-Toolbar vereinfacht */
    .editor-toolbar {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      padding: 15px;
      background: var(--editor-primary);
      border-radius: 8px;
      align-items: center;
      justify-content: space-between;
    }

    .toolbar-left {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .toolbar-info {
      color: #bdc3c7;
      font-size: 14px;
    }

    .empty-editor {
      text-align: center;
      padding: 60px 20px;
      color: #7f8c8d;
      font-size: 16px;
    }

    .empty-editor .empty-icon {
      font-size: 48px;
      margin-bottom: 20px;
      opacity: 0.5;
    }

    .editor-toolbar {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
      padding: 10px;
      background: var(--editor-primary);
      border-radius: 5px;
      flex-wrap: wrap;
    }

    .toolbar-btn {
      padding: 5px 10px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      transition: all 0.2s ease;
      min-width: 80px;
    }

    .toolbar-btn-category {
      background: #e74c3c;
      color: white;
    }

    .toolbar-btn-subcategory {
      background: #f39c12;
      color: white;
    }

    .toolbar-btn-statement {
      background: #27ae60;
      color: white;
    }

    .toolbar-btn-title {
      background: #3498db;
      color: white;
    }

    .toolbar-btn:hover {
      opacity: 0.8;
      transform: translateY(-1px);
    }

    .toolbar-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .undo-redo-section {
      display: flex;
      gap: 5px;
      margin-left: auto;
    }

    .undo-btn, .redo-btn {
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 12px;
      min-width: 60px;
      transition: all 0.2s ease;
    }

    .undo-btn:hover:not(:disabled), .redo-btn:hover:not(:disabled) {
      background: #5a6268;
    }

    .undo-btn:disabled, .redo-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .raw-json-view {
      display: none;
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
    }

    .editor-actions {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: var(--editor-accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2980b9;
    }

    .btn-success {
      background: var(--editor-success);
      color: white;
    }

    .btn-success:hover {
      background: #229954;
    }

    .btn-warning {
      background: var(--editor-warning);
      color: white;
    }

    .btn-warning:hover {
      background: #e67e22;
    }

    .btn-danger {
      background: var(--editor-danger);
      color: white;
    }

    .btn-danger:hover {
      background: #c0392b;
    }

    .status-message {
      margin-top: 15px;
      padding: 10px;
      border-radius: 5px;
      display: none;
    }

    .status-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .status-error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .new-file-form {
      background: var(--editor-primary);
      padding: 15px;
      border-radius: 5px;
      margin-top: 15px;
      display: none;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .form-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }

    .json-structure {
      background: var(--editor-primary);
      padding: 15px;
      border-radius: 5px;
      margin-top: 15px;
    }

    .structure-info {
      font-size: 12px;
      color: #bdc3c7;
      margin-bottom: 10px;
    }

    .validation-errors {
      background: var(--editor-danger);
      color: white;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      display: none;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .editor-controls {
        grid-template-columns: 1fr;
        height: auto;
      }
      
      .file-selector {
        max-height: 200px;
      }
      
      .json-content {
        min-height: 250px;
      }
      
      .editor-actions {
        flex-direction: column;
      }
      
      .btn {
        width: 100%;
        margin-bottom: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="data-editor-container">
    <div class="editor-header">
      <h1>Kidos Tools - Data Editor</h1>
      <p>JSON-Dateien bearbeiten und verwalten</p>
    </div>

    <div class="editor-controls">
      <!-- File Selector -->
      <div class="file-selector">
        <h3>JSON-Dateien</h3>
        <ul class="file-list" id="file-list">
          <!-- Wird dynamisch geladen -->
        </ul>
        
        <button class="btn btn-success" onclick="showNewFileForm()">
          ➕ Neue JSON-Datei erstellen
        </button>

        <div class="new-file-form" id="new-file-form">
          <div class="form-group">
            <label class="form-label" for="new-filename">Dateiname:</label>
            <input type="text" id="new-filename" class="form-input" placeholder="z.B. meine_bewertung.json">
          </div>
          <div class="form-group">
            <label class="form-label" for="new-title">Tool-Titel:</label>
            <input type="text" id="new-title" class="form-input" placeholder="z.B. Meine Bewertung">
          </div>
          <div class="form-group">
            <label class="form-label" for="new-description">Beschreibung:</label>
            <input type="text" id="new-description" class="form-input" placeholder="Kurze Beschreibung des Tools">
          </div>
          <button class="btn btn-success" onclick="createNewFile()">Erstellen</button>
          <button class="btn btn-warning" onclick="hideNewFileForm()">Abbrechen</button>
        </div>
      </div>

      <!-- JSON Editor -->
      <div class="json-editor">
        <h3 id="editor-title">Visueller Editor</h3>
        <div class="json-structure">
          <div class="structure-info">
            <strong>Text markieren und formatieren:</strong><br>
            • <span style="color: #e74c3c;">⬛ Kategorie</span>: Hauptüberschriften<br>
            • <span style="color: #f39c12;">⬛ Unterkategorie</span>: Unterüberschriften<br>
            • <span style="color: #27ae60;">⬛ Aussage</span>: Bewertungsaussagen<br>
            • <span style="color: #3498db;">⬛ Titel</span>: Tool-Titel
          </div>
        </div>
        
        <!-- Editor Toolbar -->
        <div class="editor-toolbar">
          <div class="toolbar-left">
            <div class="toolbar-info">
              <strong>Block-Editor:</strong> Klicken Sie auf einen Block zum Bearbeiten
            </div>
          </div>
          
          <div class="undo-redo-section">
            <button class="undo-btn" onclick="undo()" id="undo-btn" disabled>↶ Zurück</button>
            <button class="redo-btn" onclick="redo()" id="redo-btn" disabled>↷ Vor</button>
          </div>
        </div>
        
        <!-- Block-basierter Editor -->
        <div id="block-editor" class="json-content block-editor">
          <div class="empty-editor">
            <div class="empty-icon">📝</div>
            <p>Laden Sie eine JSON-Datei oder erstellen Sie eine neue Datei</p>
          </div>
        </div>
        
        <!-- Raw JSON View -->
        <div id="raw-json-view" class="raw-json-view"></div>
        
        <div class="validation-errors" id="validation-errors"></div>
        
        <div class="editor-actions">
          <button class="btn btn-success" onclick="saveToOriginalFile()" id="save-btn" disabled>💾 Datei speichern</button>
        </div>
        
        <div class="status-message" id="status-message"></div>
      </div>
    </div>
  </div>

  <script>
    // Globale Variablen
    let currentFile = null;
    let currentJsonData = null;
    let editingBlock = null;
    let blockCounter = 0;

    // Undo/Redo System
    let undoStack = [];
    let redoStack = [];
    let maxUndoSteps = 50;
    let isUndoRedoOperation = false;

    // Verfügbare JSON-Dateien
    const availableFiles = [
      'BeoKizMS1.json',
      'BeoKizMS2.json',
      'EB_STD.json',
      'EIN_STD.json',
      'Schule_STD.json',
      'Sprachstand.json'
    ];

    // Initialisierung
    document.addEventListener('DOMContentLoaded', function() {
      loadFileList();
      setupEventListeners();
      setupUndoRedoKeyboardShortcuts();
      checkServerAvailability();
    });

    // Event Listeners einrichten
    function setupEventListeners() {
      // Globaler Klick-Handler für Editor-Bereich
      document.addEventListener('click', handleGlobalClick);
      
      // Tastatur-Handler
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && editingBlock) {
          stopEditing();
        }
      });
    }

    // Globale Klick-Behandlung
    function handleGlobalClick(e) {
      const blockEditor = document.getElementById('block-editor');
      const dropdown = document.querySelector('.block-type-dropdown');
      
      // Dropdown schließen wenn außerhalb geklickt
      if (dropdown && !dropdown.contains(e.target) && !e.target.classList.contains('plus-button')) {
        dropdown.remove();
      }
      
      // Bearbeitung stoppen wenn außerhalb eines Blocks geklickt
      if (editingBlock && !e.target.closest('.content-block') && blockEditor.contains(e.target)) {
        stopEditing();
      }
    }

    // Server-Verfügbarkeit prüfen
    async function checkServerAvailability() {
      try {
        const response = await fetch('save_json.php', {
          method: 'POST',
          body: new FormData(),
          headers: {
            'X-Test-Request': 'true'
          }
        });
        
        if (response.ok) {
          console.log('Server verfügbar - direktes Speichern möglich');
          showStatus('Server verfügbar - direktes Speichern aktiviert', 'success');
        } else {
          console.log('Server nicht verfügbar - nur Download möglich');
        }
      } catch (error) {
        console.log('Server nicht verfügbar - nur Download möglich');
      }
    }

    // Tastatur-Shortcuts für Undo/Redo
    function setupUndoRedoKeyboardShortcuts() {
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
          e.preventDefault();
          redo();
        }
      });
    }

    // Dateiliste laden
    function loadFileList() {
      const fileList = document.getElementById('file-list');
      fileList.innerHTML = '';

      availableFiles.forEach(filename => {
        const li = document.createElement('li');
        li.className = 'file-item';
        li.textContent = filename;
        li.onclick = () => loadJsonFile(filename);
        fileList.appendChild(li);
      });
    }

    // JSON-Datei laden
    async function loadJsonFile(filename) {
      try {
        const response = await fetch(`data/${filename}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const jsonData = await response.json();
        
        currentJsonData = jsonData;
        currentFile = filename;
        
        // JSON in Block-Editor laden
        loadJsonToBlockEditor(jsonData);
        
        // UI aktualisieren
        document.getElementById('editor-title').textContent = `Block-Editor: ${filename}`;
        document.getElementById('save-btn').disabled = false;
        
        // Aktive Datei markieren
        document.querySelectorAll('.file-item').forEach(item => {
          item.classList.remove('active');
          if (item.textContent === filename) {
            item.classList.add('active');
          }
        });
        
        showStatus('Datei erfolgreich geladen!', 'success');
        
      } catch (error) {
        showStatus(`Fehler beim Laden der Datei: ${error.message}`, 'error');
      }
    }

    // JSON in Block-Editor laden
    function loadJsonToBlockEditor(jsonData) {
      const blockEditor = document.getElementById('block-editor');
      blockEditor.innerHTML = '';
      blockCounter = 0;
      
      // Undo/Redo zurücksetzen beim Laden einer neuen Datei
      clearUndoRedo();
      
      // Erkenne Struktur der JSON-Datei
      detectJsonStructure(jsonData);
      
      // Plus-Button am Anfang
      blockEditor.appendChild(createPlusButton(0));
      
      // Titel hinzufügen
      if (jsonData.tool_title) {
        const titleBlock = createContentBlock('title', jsonData.tool_title);
        blockEditor.appendChild(titleBlock);
        blockEditor.appendChild(createPlusButton(++blockCounter));
      }
      
      // Beschreibung hinzufügen (als erste Aussage)
      if (jsonData.tool_description) {
        const descBlock = createContentBlock('statement', jsonData.tool_description);
        blockEditor.appendChild(descBlock);
        blockEditor.appendChild(createPlusButton(++blockCounter));
      }
      
      // Kategorien, Unterkategorien und Aussagen verarbeiten
      if (jsonData.kategorien) {
        jsonData.kategorien.forEach(kategorie => {
          // Kategorie-Block
          const catBlock = createContentBlock('category', kategorie.name);
          blockEditor.appendChild(catBlock);
          blockEditor.appendChild(createPlusButton(++blockCounter));
          
          // Prüfe ob Unterkategorien als separate Arrays existieren (flache Struktur)
          if (jsonData.unterkategorien) {
            const subkategorien = jsonData.unterkategorien.filter(sub => sub.kategorie_id === kategorie.id);
            subkategorien.forEach(unterkategorie => {
              // Unterkategorie-Block
              const subBlock = createContentBlock('subcategory', unterkategorie.name);
              blockEditor.appendChild(subBlock);
              blockEditor.appendChild(createPlusButton(++blockCounter));
              
              // Aussagen dieser Unterkategorie
              if (jsonData.aussagen) {
                const aussagen = jsonData.aussagen.filter(aussage => aussage.unterkategorie_id === unterkategorie.id);
                aussagen.forEach(aussage => {
                  const aussageBlock = createContentBlock('statement', aussage.text);
                  blockEditor.appendChild(aussageBlock);
                  blockEditor.appendChild(createPlusButton(++blockCounter));
                });
              }
            });
          }
          // Prüfe ob Unterkategorien verschachtelt in der Kategorie existieren (verschachtelte Struktur wie BeoKiz)
          else if (kategorie.unterkategorien) {
            kategorie.unterkategorien.forEach(unterkategorie => {
              // Unterkategorie-Block
              const subBlock = createContentBlock('subcategory', unterkategorie.name);
              blockEditor.appendChild(subBlock);
              blockEditor.appendChild(createPlusButton(++blockCounter));
              
              // Aussagen dieser Unterkategorie
              if (unterkategorie.aussagen) {
                unterkategorie.aussagen.forEach(aussageText => {
                  const aussageBlock = createContentBlock('statement', aussageText);
                  blockEditor.appendChild(aussageBlock);
                  blockEditor.appendChild(createPlusButton(++blockCounter));
                });
              }
            });
          }
          // Flache Struktur: Aussagen direkt in der Kategorie (wie EB_STD.json)
          else if (kategorie.aussagen) {
            kategorie.aussagen.forEach(aussageText => {
              const aussageBlock = createContentBlock('statement', aussageText);
              blockEditor.appendChild(aussageBlock);
              blockEditor.appendChild(createPlusButton(++blockCounter));
            });
          }
        });
      }
      
      // Initialen Zustand für Undo speichern
      setTimeout(() => saveStateToUndo(), 100);
    }

    // Content-Block erstellen
    function createContentBlock(type, text) {
      const blockId = `block-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      const blockDiv = document.createElement('div');
      blockDiv.className = `content-block block-${type}`;
      blockDiv.setAttribute('data-type', type);
      blockDiv.setAttribute('data-block-id', blockId);
      
      const contentDiv = document.createElement('div');
      contentDiv.className = `block-content block-${type}`;
      
      const textArea = document.createElement('textarea');
      textArea.className = 'block-text';
      textArea.value = text;
      textArea.rows = 1;
      
      // Auto-resize für Textarea
      textArea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
        if (!isUndoRedoOperation) {
          saveStateToUndo();
        }
      });
      
      // Klick-Handler für Block-Bearbeitung
      blockDiv.addEventListener('click', function(e) {
        if (!e.target.classList.contains('block-btn')) {
          startEditing(blockDiv);
        }
      });
      
      contentDiv.appendChild(textArea);
      
      // Kontroll-Buttons
      const controls = document.createElement('div');
      controls.className = 'block-controls';
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'block-btn delete';
      deleteBtn.textContent = '✕';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteBlock(blockDiv);
      };
      
      controls.appendChild(deleteBtn);
      contentDiv.appendChild(controls);
      
      blockDiv.appendChild(contentDiv);
      
      // Initial-Größe setzen
      setTimeout(() => {
        textArea.style.height = 'auto';
        textArea.style.height = (textArea.scrollHeight) + 'px';
      }, 0);
      
      return blockDiv;
    }

    // Plus-Button erstellen
    function createPlusButton(position) {
      const dividerDiv = document.createElement('div');
      dividerDiv.className = 'block-divider';
      dividerDiv.setAttribute('data-position', position);
      
      const plusBtn = document.createElement('button');
      plusBtn.className = 'plus-button';
      plusBtn.textContent = '+';
      plusBtn.onclick = () => showBlockTypeDropdown(dividerDiv);
      
      dividerDiv.appendChild(plusBtn);
      
      return dividerDiv;
    }

    // Block-Typ Dropdown anzeigen
    function showBlockTypeDropdown(dividerElement) {
      // Vorhandenes Dropdown entfernen
      const existingDropdown = document.querySelector('.block-type-dropdown');
      if (existingDropdown) {
        existingDropdown.remove();
      }
      
      const dropdown = document.createElement('div');
      dropdown.className = 'block-type-dropdown';
      dropdown.style.display = 'block';
      
      const options = [
        { type: 'title', label: 'Titel', icon: 'T' },
        { type: 'category', label: 'Kategorie', icon: 'K' },
        { type: 'subcategory', label: 'Unterkategorie', icon: 'U' },
        { type: 'statement', label: 'Aussage', icon: 'A' }
      ];
      
      options.forEach(option => {
        const optionDiv = document.createElement('div');
        optionDiv.className = `block-type-option ${option.type}`;
        
        const iconDiv = document.createElement('div');
        iconDiv.className = 'icon';
        iconDiv.textContent = option.icon;
        
        const labelSpan = document.createElement('span');
        labelSpan.textContent = option.label;
        
        optionDiv.appendChild(iconDiv);
        optionDiv.appendChild(labelSpan);
        
        optionDiv.onclick = () => {
          insertNewBlock(dividerElement, option.type);
          dropdown.remove();
        };
        
        dropdown.appendChild(optionDiv);
      });
      
      dividerElement.appendChild(dropdown);
    }

    // Neuen Block einfügen
    function insertNewBlock(dividerElement, type) {
      const placeholder = type === 'title' ? 'Titel eingeben...' :
                         type === 'category' ? 'Kategorie eingeben...' :
                         type === 'subcategory' ? 'Unterkategorie eingeben...' :
                         'Aussage eingeben...';
      
      const newBlock = createContentBlock(type, placeholder);
      const newDivider = createPlusButton(++blockCounter);
      
      // Nach dem Divider einfügen
      dividerElement.parentNode.insertBefore(newBlock, dividerElement.nextSibling);
      dividerElement.parentNode.insertBefore(newDivider, newBlock.nextSibling);
      
      // Sofort in Bearbeitungsmodus wechseln
      setTimeout(() => {
        startEditing(newBlock);
        const textarea = newBlock.querySelector('.block-text');
        textarea.select();
      }, 0);
      
      saveStateToUndo();
    }

    // Block-Bearbeitung starten
    function startEditing(blockElement) {
      if (editingBlock && editingBlock !== blockElement) {
        stopEditing();
      }
      
      editingBlock = blockElement;
      blockElement.classList.add('editing');
      
      const textarea = blockElement.querySelector('.block-text');
      textarea.classList.add('editing');
      textarea.focus();
      
      // Cursor ans Ende setzen
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }

    // Block-Bearbeitung stoppen
    function stopEditing() {
      if (editingBlock) {
        editingBlock.classList.remove('editing');
        const textarea = editingBlock.querySelector('.block-text');
        textarea.classList.remove('editing');
        textarea.blur();
        editingBlock = null;
      }
    }

    // Block löschen
    function deleteBlock(blockElement) {
      if (confirm('Block wirklich löschen?')) {
        const nextDivider = blockElement.nextElementSibling;
        if (nextDivider && nextDivider.classList.contains('block-divider')) {
          nextDivider.remove();
        }
        blockElement.remove();
        saveStateToUndo();
      }
    }

    // Undo/Redo Funktionen
    function saveStateToUndo() {
      if (isUndoRedoOperation) return;
      
      const blockEditor = document.getElementById('block-editor');
      const currentState = blockEditor.innerHTML;
      
      undoStack.push(currentState);
      redoStack = [];
      
      if (undoStack.length > maxUndoSteps) {
        undoStack.shift();
      }
      
      updateUndoRedoButtons();
    }

    function undo() {
      if (undoStack.length === 0) return;
      
      const blockEditor = document.getElementById('block-editor');
      const currentState = blockEditor.innerHTML;
      
      redoStack.push(currentState);
      const previousState = undoStack.pop();
      
      isUndoRedoOperation = true;
      blockEditor.innerHTML = previousState;
      setupBlockEventListeners();
      isUndoRedoOperation = false;
      
      updateUndoRedoButtons();
      showStatus('Änderung rückgängig gemacht', 'success');
    }

    function redo() {
      if (redoStack.length === 0) return;
      
      const blockEditor = document.getElementById('block-editor');
      const currentState = blockEditor.innerHTML;
      
      undoStack.push(currentState);
      const nextState = redoStack.pop();
      
      isUndoRedoOperation = true;
      blockEditor.innerHTML = nextState;
      setupBlockEventListeners();
      isUndoRedoOperation = false;
      
      updateUndoRedoButtons();
      showStatus('Änderung wiederhergestellt', 'success');
    }

    function updateUndoRedoButtons() {
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      
      undoBtn.disabled = undoStack.length === 0;
      redoBtn.disabled = redoStack.length === 0;
      
      undoBtn.textContent = `↶ Zurück (${undoStack.length})`;
      redoBtn.textContent = `↷ Vor (${redoStack.length})`;
    }

    function clearUndoRedo() {
      undoStack = [];
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Event Listeners nach Undo/Redo neu einrichten
    function setupBlockEventListeners() {
      const blocks = document.querySelectorAll('.content-block');
      blocks.forEach(block => {
        const textarea = block.querySelector('.block-text');
        const deleteBtn = block.querySelector('.block-btn.delete');
        
        // Block-Klick-Handler
        block.onclick = function(e) {
          if (!e.target.classList.contains('block-btn')) {
            startEditing(block);
          }
        };
        
        // Textarea-Handler
        if (textarea) {
          textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
            if (!isUndoRedoOperation) {
              saveStateToUndo();
            }
          });
        }
        
        // Delete-Button-Handler
        if (deleteBtn) {
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            deleteBlock(block);
          };
        }
      });
      
      // Plus-Button-Handler
      const plusButtons = document.querySelectorAll('.plus-button');
      plusButtons.forEach(button => {
        button.onclick = () => showBlockTypeDropdown(button.parentNode);
      });
    }

    // JSON aus Blöcken generieren
    // Globale Variable für Original-Struktur
    let originalStructureType = 'nested'; // 'nested' oder 'flat'

    // Erkenne JSON-Struktur
    function detectJsonStructure(jsonData) {
      if (jsonData.kategorien && jsonData.kategorien.length > 0) {
        const firstKategorie = jsonData.kategorien[0];
        
        // Flache Struktur: Kategorie hat direkt aussagen (wie EB_STD.json)
        if (firstKategorie.aussagen && !firstKategorie.unterkategorien) {
          originalStructureType = 'flat';
        }
        // Verschachtelte Struktur: Kategorie hat unterkategorien (wie BeoKizMS1.json)
        else if (firstKategorie.unterkategorien) {
          originalStructureType = 'nested';
        }
        // Separate Arrays Struktur (alte Variante)
        else if (jsonData.unterkategorien) {
          originalStructureType = 'flat';
        }
        else {
          originalStructureType = 'nested'; // Default
        }
      }
      
      console.log('Erkannte JSON-Struktur:', originalStructureType);
    }

    function generateJsonFromBlocks() {
      const blocks = document.querySelectorAll('.content-block');
      
      // Bestimme Struktur basierend auf ursprünglicher Datei
      if (originalStructureType === 'flat') {
        return generateFlatJsonFromBlocks(blocks);
      } else {
        return generateNestedJsonFromBlocks(blocks);
      }
    }

    // Flache Struktur für EB_STD.json (kategorien -> aussagen direkt)
    function generateFlatJsonFromBlocks(blocks) {
      const jsonData = {
        kategorien: []
      };
      
      let currentKategorie = null;
      
      blocks.forEach(block => {
        const type = block.getAttribute('data-type');
        const text = block.querySelector('.block-text').value.trim();
        
        if (!text) return;
        
        switch (type) {
          case 'category':
            currentKategorie = {
              name: text,
              aussagen: []
            };
            jsonData.kategorien.push(currentKategorie);
            break;
            
          case 'statement':
            if (currentKategorie) {
              currentKategorie.aussagen.push(text);
            }
            break;
        }
      });
      
      return jsonData;
    }

    // Verschachtelte Struktur für BeoKizMS1.json (kategorien -> unterkategorien -> aussagen)
    function generateNestedJsonFromBlocks(blocks) {
      const jsonData = {
        kategorien: []
      };
      
      let currentKategorie = null;
      let currentUnterkategorie = null;
      
      blocks.forEach(block => {
        const type = block.getAttribute('data-type');
        const text = block.querySelector('.block-text').value.trim();
        
        if (!text) return;
        
        switch (type) {
          case 'category':
            currentKategorie = {
              name: text,
              unterkategorien: []
            };
            jsonData.kategorien.push(currentKategorie);
            currentUnterkategorie = null;
            break;
            
          case 'subcategory':
            if (currentKategorie) {
              currentUnterkategorie = {
                name: text,
                aussagen: []
              };
              currentKategorie.unterkategorien.push(currentUnterkategorie);
            }
            break;
            
          case 'statement':
            if (currentUnterkategorie) {
              currentUnterkategorie.aussagen.push(text);
            } else if (currentKategorie) {
              // Falls Statement direkt nach Kategorie kommt
              if (!currentKategorie.aussagen) {
                currentKategorie.aussagen = [];
              }
              currentKategorie.aussagen.push(text);
            }
            break;
        }
      });
      
      return jsonData;
    }

    // Vereinfachte Speicherfunktion - direkt in Originaldatei
    async function saveToOriginalFile() {
      currentJsonData = generateJsonFromBlocks();
      
      // Einfache Validierung
      if (!currentJsonData || !currentJsonData.kategorien || currentJsonData.kategorien.length === 0) {
        showStatus('Fehler: Keine Kategorien vorhanden! Erstellen Sie mindestens eine Kategorie.', 'error');
        return;
      }
      
      if (!currentFile) {
        showStatus('Keine Datei ausgewählt!', 'error');
        return;
      }
      
      const content = JSON.stringify(currentJsonData, null, 2);
      
      // Versuche 1: PHP-Server Speichern
      try {
        const formData = new FormData();
        formData.append('filename', currentFile);
        formData.append('content', content);
        formData.append('action', 'save');
        
        const response = await fetch('save_json.php', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Server antwortet nicht (${response.status})`);
        }
        
        const result = await response.json();
        
        if (result.success) {
          showStatus(`✅ Datei ${currentFile} erfolgreich gespeichert!`, 'success');
          return;
        } else {
          throw new Error(result.message || 'Server-Fehler');
        }
        
      } catch (error) {
        console.log('PHP-Server Speichern fehlgeschlagen:', error.message);
        
        // Versuche 2: File System Access API (moderne Browser)
        try {
          if ('showSaveFilePicker' in window) {
            const fileHandle = await window.showSaveFilePicker({
              suggestedName: currentFile,
              types: [{
                description: 'JSON files',
                accept: {'application/json': ['.json']},
              }],
            });
            
            const writable = await fileHandle.createWritable();
            await writable.write(content);
            await writable.close();
            
            showStatus(`✅ Datei ${currentFile} erfolgreich gespeichert!`, 'success');
            return;
          }
        } catch (fileError) {
          if (fileError.name !== 'AbortError') {
            console.log('File System API fehlgeschlagen:', fileError.message);
          }
        }
        
        // Fallback 3: Download anbieten mit detaillierter Anleitung
        const userChoice = confirm(
          `⚠️ Direktes Speichern nicht möglich.\n\n` +
          `Grund: ${error.message}\n\n` +
          `Die Datei wird heruntergeladen. WICHTIG:\n` +
          `1. Öffnen Sie den Downloads-Ordner\n` +
          `2. Kopieren Sie "${currentFile}" in den data/ Ordner\n` +
          `3. Überschreiben Sie die alte Datei\n` +
          `4. Laden Sie die App neu (F5)\n\n` +
          `Fortfahren?`
        );
        
        if (userChoice) {
          // Automatischer Download
          const blob = new Blob([content], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = currentFile;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          // Detaillierte Erfolgsmeldung mit Anleitung
          showStatus(`📥 Datei ${currentFile} heruntergeladen!`, 'success');
          
          // Zusätzliche Anleitung anzeigen
          setTimeout(() => {
            alert(
              `✅ Download abgeschlossen!\n\n` +
              `NÄCHSTE SCHRITTE:\n` +
              `1. Öffnen Sie Ihren Downloads-Ordner\n` +
              `2. Suchen Sie die Datei "${currentFile}"\n` +
              `3. Kopieren Sie diese Datei\n` +
              `4. Navigieren Sie zum Ordner:\n` +
              `   ${window.location.href.replace('/data_edit.html', '/data/')}\n` +
              `5. Fügen Sie die Datei ein und überschreiben Sie die alte\n` +
              `6. Laden Sie dann Ihre App neu (F5)\n\n` +
              `Die Änderungen werden erst nach dem Neuladen sichtbar!`
            );
          }, 1000);
          
        } else {
          showStatus(`❌ Speichern abgebrochen`, 'error');
        }
      }
    }

    // JSON validieren
    function validateJson() {
      currentJsonData = generateJsonFromBlocks();
      
      const errorsDiv = document.getElementById('validation-errors');
      
      try {
        const jsonData = currentJsonData;
        errorsDiv.style.display = 'none';
        
        const requiredFields = ['tool_title', 'tool_description', 'kategorien', 'unterkategorien', 'aussagen'];
        const missingFields = [];
        
        requiredFields.forEach(field => {
          if (!jsonData.hasOwnProperty(field)) {
            missingFields.push(field);
          }
        });
        
        if (missingFields.length > 0) {
          errorsDiv.innerHTML = `<strong>Fehlende Felder:</strong> ${missingFields.join(', ')}`;
          errorsDiv.style.display = 'block';
          return false;
        }
        
        showStatus('JSON ist gültig!', 'success');
        return true;
        
      } catch (error) {
        errorsDiv.innerHTML = `<strong>JSON-Syntax-Fehler:</strong> ${error.message}`;
        errorsDiv.style.display = 'block';
        showStatus('JSON-Validierung fehlgeschlagen!', 'error');
        return false;
      }
    }

    // JSON formatieren
    function formatJson() {
      currentJsonData = generateJsonFromBlocks();
      showStatus('JSON aus Blöcken generiert!', 'success');
    }

    // JSON herunterladen
    function downloadJson() {
      currentJsonData = generateJsonFromBlocks();
      
      if (!validateJson()) {
        return;
      }
      
      const content = JSON.stringify(currentJsonData, null, 2);
      const filename = currentFile || 'new_file.json';
      
      const blob = new Blob([content], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showStatus(`Datei ${filename} wurde heruntergeladen!`, 'success');
    }

    // Aktuelle Datei löschen
    function deleteCurrentFile() {
      if (!currentFile) {
        showStatus('Keine Datei ausgewählt!', 'error');
        return;
      }
      
      if (confirm(`Möchten Sie die Datei "${currentFile}" aus dem Editor entfernen?\n\nHinweis: Die ursprüngliche Datei bleibt unverändert.`)) {
        const blockEditor = document.getElementById('block-editor');
        blockEditor.innerHTML = '<div class="empty-editor"><div class="empty-icon">📝</div><p>Laden Sie eine JSON-Datei oder erstellen Sie eine neue Datei</p></div>';
        
        document.getElementById('editor-title').textContent = 'Block-Editor';
        document.getElementById('save-btn').disabled = true;
        document.getElementById('delete-btn').disabled = true;
        
        document.querySelectorAll('.file-item').forEach(item => {
          item.classList.remove('active');
        });
        
        currentFile = null;
        currentJsonData = null;
        
        showStatus('Datei aus dem Editor entfernt!', 'success');
      }
    }

    // Neue Datei erstellen
    function createNewFile() {
      const filename = document.getElementById('new-filename').value.trim();
      const title = document.getElementById('new-title').value.trim();
      const description = document.getElementById('new-description').value.trim();
      
      if (!filename || !title || !description) {
        showStatus('Bitte füllen Sie alle Felder aus!', 'error');
        return;
      }
      
      if (!filename.endsWith('.json')) {
        showStatus('Dateiname muss mit .json enden!', 'error');
        return;
      }
      
      const template = {
        "tool_title": title,
        "tool_description": description,
        "kategorien": [
          {
            "id": "kategorie1",
            "name": "Beispiel Kategorie",
            "description": "Beschreibung der Kategorie"
          }
        ],
        "unterkategorien": [
          {
            "id": "unterkategorie1",
            "name": "Beispiel Unterkategorie",
            "kategorie_id": "kategorie1"
          }
        ],
        "aussagen": [
          {
            "id": "aussage1",
            "text": "Beispiel Aussage",
            "unterkategorie_id": "unterkategorie1",
            "bewertung_optionen": [
              "Nicht beobachtet",
              "Ansätze erkennbar",
              "Teilweise vorhanden",
              "Voll entwickelt"
            ]
          }
        ]
      };
      
      loadJsonToBlockEditor(template);
      currentFile = filename;
      currentJsonData = template;
      
      document.getElementById('editor-title').textContent = `Block-Editor: ${filename} (neu)`;
      document.getElementById('save-btn').disabled = false;
      
      hideNewFileForm();
      
      showStatus(`Neue Datei "${filename}" erstellt!`, 'success');
    }

    // Neue Datei Form anzeigen
    function showNewFileForm() {
      document.getElementById('new-file-form').style.display = 'block';
      document.getElementById('new-filename').focus();
    }

    // Neue Datei Form verstecken
    function hideNewFileForm() {
      document.getElementById('new-file-form').style.display = 'none';
      document.getElementById('new-filename').value = '';
      document.getElementById('new-title').value = '';
      document.getElementById('new-description').value = '';
    }

    // Status-Nachricht anzeigen
    function showStatus(message, type) {
      const statusDiv = document.getElementById('status-message');
      statusDiv.textContent = message;
      statusDiv.className = `status-message status-${type}`;
      statusDiv.style.display = 'block';
      
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 's':
            e.preventDefault();
            saveJson();
            break;
          case 'n':
            e.preventDefault();
            showNewFileForm();
            break;
        }
      }
    });

    // Backup erstellen
    async function createBackup(filename, jsonData) {
      try {
        const backupName = filename.replace('.json', '_backup.json');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupContent = {
          original_file: filename,
          backup_created: timestamp,
          backup_data: jsonData
        };
        
        // Backup in localStorage speichern
        localStorage.setItem(`backup_${filename}`, JSON.stringify(backupContent, null, 2));
        
        console.log(`Backup für ${filename} erstellt: ${backupName}`);
        
      } catch (error) {
        console.error('Fehler beim Erstellen des Backups:', error);
      }
    }

    // Backup wiederherstellen
    function restoreBackup(filename) {
      try {
        const backupKey = `backup_${filename}`;
        const backupData = localStorage.getItem(backupKey);
        
        if (!backupData) {
          showStatus(`Kein Backup für ${filename} gefunden!`, 'error');
          return;
        }
        
        const backup = JSON.parse(backupData);
        
        if (confirm(`Backup vom ${backup.backup_created} wiederherstellen?\n\nAktuelle Änderungen gehen verloren!`)) {
          // Backup-Daten in visuellen Editor laden
          loadJsonToVisualEditor(backup.backup_data);
          currentJsonData = backup.backup_data;
          
          showStatus(`Backup für ${filename} wiederhergestellt!`, 'success');
        }
        
      } catch (error) {
        showStatus(`Fehler beim Wiederherstellen des Backups: ${error.message}`, 'error');
      }
    }

    // Backup herunterladen
    function downloadBackup(filename) {
      try {
        const backupKey = `backup_${filename}`;
        const backupData = localStorage.getItem(backupKey);
        
        if (!backupData) {
          showStatus(`Kein Backup für ${filename} gefunden!`, 'error');
          return;
        }
        
        const backup = JSON.parse(backupData);
        const backupFilename = filename.replace('.json', '_backup.json');
        
        // Nur die Original-Daten herunterladen (ohne Metadaten)
        const content = JSON.stringify(backup.backup_data, null, 2);
        
        const blob = new Blob([content], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = backupFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(`Backup ${backupFilename} heruntergeladen!`, 'success');
        
      } catch (error) {
        showStatus(`Fehler beim Herunterladen des Backups: ${error.message}`, 'error');
      }
    }

    // Alle Backups anzeigen
    function showBackupInfo() {
      const backups = [];
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('backup_')) {
          try {
            const backup = JSON.parse(localStorage.getItem(key));
            backups.push({
              file: backup.original_file,
              created: backup.backup_created,
              key: key
            });
          } catch (e) {
            console.error('Fehler beim Laden des Backups:', key, e);
          }
        }
      }
      
      if (backups.length === 0) {
        alert('Keine Backups gefunden!');
        return;
      }
      
      let message = 'Verfügbare Backups:\n\n';
      backups.forEach(backup => {
        message += `📁 ${backup.file}\n`;
        message += `   Erstellt: ${backup.created}\n\n`;
      });
      
      alert(message);
    }

    // JSON validieren
    function validateJson() {
      // Aktuellste Daten aus visuellem Editor holen
      updateRawJsonView();
      
      const errorsDiv = document.getElementById('validation-errors');
      
      try {
        const jsonData = currentJsonData;
        errorsDiv.style.display = 'none';
        
        // Struktur validieren
        const requiredFields = ['tool_title', 'tool_description', 'kategorien', 'unterkategorien', 'aussagen'];
        const missingFields = [];
        
        requiredFields.forEach(field => {
          if (!jsonData.hasOwnProperty(field)) {
            missingFields.push(field);
          }
        });
        
        if (missingFields.length > 0) {
          errorsDiv.innerHTML = `<strong>Fehlende Felder:</strong> ${missingFields.join(', ')}`;
          errorsDiv.style.display = 'block';
          return false;
        }
        
        showStatus('JSON ist gültig!', 'success');
        return true;
        
      } catch (error) {
        errorsDiv.innerHTML = `<strong>JSON-Syntax-Fehler:</strong> ${error.message}`;
        errorsDiv.style.display = 'block';
        showStatus('JSON-Validierung fehlgeschlagen!', 'error');
        return false;
      }
    }

    // JSON formatieren
    function formatJson() {
      updateRawJsonView();
      showStatus('Inhalt aktualisiert!', 'success');
    }

    // JSON speichern (Original überschreiben)
    async function saveJson() {
      // Aktuellste Daten aus visuellem Editor holen
      updateRawJsonView();
      
      if (!validateJson()) {
        return;
      }
      
      if (!currentFile) {
        showStatus('Keine Datei ausgewählt! Verwenden Sie "Download" für neue Dateien.', 'error');
        return;
      }
      
      try {
        const content = JSON.stringify(currentJsonData, null, 2);
        
        // Versuche die Datei über File System Access API zu speichern
        if ('showSaveFilePicker' in window) {
          await saveWithFileSystemAPI(content, currentFile);
        } else {
          // Fallback: PHP-Script nutzen (falls verfügbar)
          await saveWithPHPScript(content, currentFile);
        }
        
      } catch (error) {
        console.error('Speichern fehlgeschlagen:', error);
        showStatus(`Speichern fehlgeschlagen: ${error.message}`, 'error');
        
        // Fallback: Download anbieten
        showDownloadFallback();
      }
    }
    
    // Speichern mit File System Access API (moderne Browser)
    async function saveWithFileSystemAPI(content, filename) {
      try {
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{
            description: 'JSON files',
            accept: {'application/json': ['.json']},
          }],
        });
        
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        
        showStatus(`Datei ${filename} erfolgreich gespeichert!`, 'success');
      } catch (error) {
        if (error.name !== 'AbortError') {
          throw error;
        }
      }
    }
    
    // Speichern mit PHP-Script (Server-Lösung)
    async function saveWithPHPScript(content, filename) {
      const formData = new FormData();
      formData.append('filename', filename);
      formData.append('content', content);
      formData.append('action', 'save');
      
      const response = await fetch('save_json.php', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error(`Server-Fehler: ${response.status}`);
      }
      
      const result = await response.json();
      
      if (result.success) {
        showStatus(`Datei ${filename} erfolgreich auf Server gespeichert!`, 'success');
      } else {
        throw new Error(result.message || 'Unbekannter Server-Fehler');
      }
    }
    
    // Download-Fallback anzeigen
    function showDownloadFallback() {
      if (confirm('Direktes Speichern nicht möglich. Möchten Sie die Datei stattdessen herunterladen?')) {
        downloadJson();
      }
    }

    // JSON herunterladen
    function downloadJson() {
      // Aktuellste Daten aus visuellem Editor holen
      updateRawJsonView();
      
      if (!validateJson()) {
        return;
      }
      
      const content = JSON.stringify(currentJsonData, null, 2);
      const filename = currentFile || 'new_file.json';
      
      const blob = new Blob([content], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showStatus(`Datei ${filename} wurde heruntergeladen!`, 'success');
    }

    // Aktuelle Datei löschen
    function deleteCurrentFile() {
      if (!currentFile) {
        showStatus('Keine Datei ausgewählt!', 'error');
        return;
      }
      
      if (confirm(`Möchten Sie die Datei "${currentFile}" wirklich löschen?\n\nHinweis: Dies ist nur eine Simulation - die ursprüngliche Datei bleibt erhalten.`)) {
        // Reset UI
        document.getElementById('visual-editor').innerHTML = '<div class="content-item item-title"><span>Klicken Sie hier, um den Titel zu bearbeiten</span></div>';
        document.getElementById('editor-title').textContent = 'Visueller Editor';
        document.getElementById('save-btn').disabled = true;
        document.getElementById('delete-btn').disabled = true;
        document.getElementById('restore-btn').disabled = true;
        document.getElementById('backup-download-btn').disabled = true;
        
        // Aktive Markierung entfernen
        document.querySelectorAll('.file-item').forEach(item => {
          item.classList.remove('active');
        });
        
        currentFile = null;
        currentJsonData = null;
        
        showStatus('Datei aus dem Editor entfernt!', 'success');
      }
    }

    // Neue Datei erstellen
    function createNewFile() {
      const filename = document.getElementById('new-filename').value.trim();
      const title = document.getElementById('new-title').value.trim();
      const description = document.getElementById('new-description').value.trim();
      
      if (!filename || !title || !description) {
        showStatus('Bitte füllen Sie alle Felder aus!', 'error');
        return;
      }
      
      if (!filename.endsWith('.json')) {
        showStatus('Dateiname muss mit .json enden!', 'error');
        return;
      }
      
      // Template für neue JSON-Datei
      const template = {
        "tool_title": title,
        "tool_description": description,
        "kategorien": [
          {
            "id": "kategorie1",
            "name": "Beispiel Kategorie",
            "description": "Beschreibung der Kategorie"
          }
        ],
        "unterkategorien": [
          {
            "id": "unterkategorie1",
            "name": "Beispiel Unterkategorie",
            "kategorie_id": "kategorie1"
          }
        ],
        "aussagen": [
          {
            "id": "aussage1",
            "text": "Beispiel Aussage",
            "unterkategorie_id": "unterkategorie1",
            "bewertung_optionen": [
              "Nicht beobachtet",
              "Ansätze erkennbar",
              "Teilweise vorhanden",
              "Voll entwickelt"
            ]
          }
        ]
      };
      
      // JSON in visuellen Editor laden
      loadJsonToVisualEditor(template);
      currentFile = filename;
      currentJsonData = template;
      
      // UI aktualisieren
      document.getElementById('editor-title').textContent = `Editor: ${filename} (neu)`;
      document.getElementById('save-btn').disabled = false;
      document.getElementById('delete-btn').disabled = false;
      document.getElementById('restore-btn').disabled = true; // Keine Backups für neue Dateien
      document.getElementById('backup-download-btn').disabled = true; // Keine Backups für neue Dateien
      
      // Form verstecken
      hideNewFileForm();
      
      showStatus(`Neue Datei "${filename}" erstellt!`, 'success');
    }

    // Neue Datei Form anzeigen
    function showNewFileForm() {
      document.getElementById('new-file-form').style.display = 'block';
      document.getElementById('new-filename').focus();
    }

    // Neue Datei Form verstecken
    function hideNewFileForm() {
      document.getElementById('new-file-form').style.display = 'none';
      document.getElementById('new-filename').value = '';
      document.getElementById('new-title').value = '';
      document.getElementById('new-description').value = '';
    }

    // Status-Nachricht anzeigen
    function showStatus(message, type) {
      const statusDiv = document.getElementById('status-message');
      statusDiv.textContent = message;
      statusDiv.className = `status-message status-${type}`;
      statusDiv.style.display = 'block';
      
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 's':
            e.preventDefault();
            saveToOriginalFile();
            break;
        }
      }
    });
  </script>
</body>
</html>
